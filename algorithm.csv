3x+1問題:Syracuseアルゴリズム|Collatzの問題|角谷の予測,
変数の交換:スワップ|swap,
退避変数:tempotary,
プログラムのメモリ使用量:空間計算量|space complexity,
プログラムのかかる時間:時間計算量|time complexity,
アルゴリズムにかかる条件、留意すべき点:制約|constraint,
ループにより結果が狂わないこと:ループ不変条件|loop invariant,
表明:assertion,
疑似コード:pseudo code,
反復:iteration,
再帰:recursion,
抽象化:abstraction,
最短路問題:shortest path problem|Dijkstraのアルゴリズム,
データ構造:data structure,
列:sequence,
木:tree,
グラフ:graph,
探索:search,
整列:sorting,
最適化:optimization,
正当性:validity,
計算量:complexity,
線形探索:linear search,
二分探索:binary search,
漸近的:asymptotic,
O記法:O-notation|ランダウの記号(Landau notation),
O(2^n)のアルゴリズム:ナップザック問題,
O(n!)のアルゴリズム:巡回セールスマン問題,
nの増加で膨大な計算量が生じること:組み合わせ的爆発(combinatorial explosion),
3つの計算時間:best case|worst case|average case,
実装:implementation,
問題のサイズが増大しても計算できること:スケーラビリティ(scalability),
実験的評価:empirical evaluation,
保全性:maintainability,
データが本来持っている抽象的な構造:論理構造(logical structure)|外部構造(external structure),
コンピュータ内部に格納する構造:物理構造(physical structure)|内部構造(internal structure),
型:type,
操作:manipulation|operation,
配列:array,
プログラム実行時に個数などが固定されていること:静的(static),
要素をポインタで一列に繋いだリスト:linked list|linear list,
無値、空値:null,
リストの反復処理中に現在処理しているもの:現在子(currency pointer),
値の参照はランダムアクセスできない（任意の場所にいきなり飛べない）性質:逐次的(sequential),
リストの挿入時にその繋ぎ目を処理すること:境界処理(boundary processing),
実行時に何かに応じて個数などを変えられること:動的(dynamic),
改良型:variant,
要素の最後が先頭を指すようになっているリスト:環状リスト(circular list),
各要素が次の要素と前の要素のポインタを所持するリスト:双方向リスト(doubly linked list),
任意のアクセスを許さず、端だけでアクセスすること:カプセル化(encapsulation),
最後に入れたデータが最初に出てくること:LIFO(Last In First Out),
スタックに何か積むこと:push,
スタックから取り出すこと:pop,
スタックが列の実装した性質をそのまま持つこと:継承(inheritance),
演算子、数字、数字のフォーマットで数式を表現する方法:ポーランド記法(Polish Notation),
数字、数字、演算子のフォーマットで数式を表現する方法:逆ポーランド記法(Reverse Polish Notation),
待ち行列:queue,
最初に入れたデータは最初に出てくる:FIFO(First In First Out),
ポインタが端から外れた際に先頭に戻ることで輪を構成するバッファ:ring buffer,
階層:hierarchy,
頂点:node|vertex,
根:root,
内部頂点:internal node,
葉:leaf,
枝:branch,
親:parent,
子:child,
兄弟:sibling,
祖先:ancestor,
子孫:descendant,
部分木:subtree,
深さ:depth,
高さ:height,
右と左にそれぞれ部分木を持つ木:二分木(binary tree),
根から葉が決まっている木:方向木(directed tree),
右部分木と左部分木に決まりがある木:順序木(ordered tree),
二分木の要素を全てたどること:走査(traversal),
二分木の親を調べてから子を調べて要素を辿ること:前順走査(pre-order traversal),
二分木の子を調べてから親、残りの子を辿ること:間順走査(in-order traversal),
子を全て調べてから親を辿ること:後順走査(post-order traversal),
自由度の高い構造を特定の性質に応じて作り直すこと:特化(specialization),
特定の性質を持つ構造を自由度を上げてさまざまな用途に使えるようにすること:汎化(generalization),
表:table,
表の一行の要素の集まり:レコード(record),
表の要素１つ:フィールド(field),
同じ値が2回現れない性質を持つもの:識別子(identifier),
フィールドの中で識別子であり、無値があり得ないもの:キー(key),
入力キー値に対応するレコードを選ぶ走査:探索(search),
ループ条件を簡素化するために意図的に設定された要素:番兵(sentinel),
要素のアクセスが集中することを利用して構成し直すリスト:自己再構成リスト(self re-organizing list),
要素のアクセスが特定の時間に集中する性質:局所性(locality),
効率:efficiency,
性能:performance,
ネゲントロピー:アルゴリズムに必要なエネルギー,
各ノードの左側が自身より小さく、右側が自身より大きい木:二分探索木(binary search tree),
ある値が表す元の意味が一通りであること:一意(unique),
ある値の読み取りかたが一通りであること:一義的(unambiguous),
再帰の最後が自身の呼び出しである場合高速化できること:末尾再帰呼び出しの除去(tail recursion removal),
木が線形にならないようバランスをとって高さを抑えるもの:平衡木(balanced tree),
全てのノードで左右の部分木の個数の差が1以内であるもの:完全二分木(complete binary tree),
ノードの再配置の手間のこと:操作感度(operational sensitivity),
左右の部分木の高さの差が1以内の木:AVL木,
AVL木を保つために長くなり過ぎた木を付け替えて親を根にする処理:一重回転(single rotation),
AVL木を保つために長くなり過ぎた木を分割して親を根にする処理:二重回転(double rotation),
子が2以上分岐する木:多分木(multiway tree),
天井関数:ceiling function,
分岐数を増やすことで木の高さを減少させ、二次記憶での保存に適した探索木:B-tree,
キーの取りうる値を全て配列にすることで探索する方法:ハッシュ法(hash),
もとの値がすこし違っても大きく返り値が変わる関数:hash関数,
ハッシュ法でダウンサイズをするとハッシュの値が被ってしまうこと:衝突(collision),
衝突した場合、線形リストに入れてしまう方法:チェイン法(chaining),
衝突した場合、本来は入らない場所に入れてしまう:開番地法,
開番地法においてハッシュ値の違うレコードが入り過ぎて効率が低下すること:clustering|アーティファクト,
数の小さいものを前に並べることでソートする方法:bubble sort,
先頭から後方へ向かって最小値を探し、ループの最後に交換を行うソート:選択法(selection sort),
ループの中で結果を記録し、最後に結果に応じて処理を行うこと:遅延評価(lazy evaluation),
洗練:refinement,
挿入時に左側の整列を行うことでソートを早める方法:挿入法(insertion sort),
決定木:decision tree,
飛び飛びの値を整列し、徐々に細かくすることで行う整列:シェルソート(Shell sort),
段階的詳述化:progressive refinement,
基準値を設け、大きいものを右に、小さいものを左に設定することで行う整列:クイックソート(quick sort),
分割統治:devide and conquer,
部分的に大小関係のついた構造を生成して行う整列:ヒープソート(heap sort),
左側に小さい数字、右側に大きい数字を入れておく木:ヒープ(heap),
部分順序付き木:partially ordered tree,
整列ずみの2本の列を併合することで行う整列:マージソート(merge),
キーの数だけ配列を用意して番号ごとに配置することで行う整列:ビンソート(bin sort),
性能がデータに依存しにくいこと:安全性,
同一のキー値を持つものならばソート状態が保たれること:安定性,
キー値を基底を用いて徐々に整列する方法:基底法(radix sort),
辺:edge,
向きのついたグラフ:有向グラフ(directed graph),
向きの固定されていないグラフ:無向グラフ(undirected graph),
重み:weight,
重み付きグラフ:weighted graph,
路:path,
閉路:cycle,
単純路:simple path,
密な:dense,
疎な:sparse,
非連結な木の集合:森(forest),
グラフの辺をつながっているとき1、繋がっていない時0と表す行列:隣接行列(adjancency matrix),
グラフの表現方法二つ:行列表現|リスト表現,
グラフにおいて行けるとことまで行き、進めなくなったら元に戻る探索:深さ優先探索(depth-first search),
グラフから深さ優先探索により生成される木:張る木(spanning tree)|極大木|全域木,
全域木に含まれる辺:木の辺(tree edge),
全域木に含まれない辺:逆辺(back edge),
逆辺のうち、子孫から祖先へと繋がっている辺:上昇辺(up edge),
祖先から子孫へと繋がっている辺:下降辺(down edge),
逆辺のうち、上昇も下降もしない辺:交差辺(cross edge),
グラフにおいて一つの頂点からつながる全ての頂点を訪問してからその頂点一つについて探索を行う方式:幅優先探索(breadth-first search),
無向グラフにおいて、全辺の重みの合計が最小となる木:最小木(Minimum Spanning Tree),
最小木を求める際のアルゴリズム2つ:Primのアルゴリズム|Kruskalのアルゴリズム,
有向グラフにおいて2頂点の間の経路の重み合計が最小となるものを求める問題:最短路問題(shortest path problem)